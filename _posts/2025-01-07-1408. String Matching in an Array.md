---
layout: post
title: 1408. String Matching in an Array
image: Mine/1695467332794.jpg
date: 2025-01-07 20:00:00 +0900
tags: [Problem_Solving]
categories: Problem_Solving
difficulty: Easy
topics: [Array, String, String Matching]
---

[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/string-matching-in-an-array/description/?envType=daily-question&envId=2025-01-07)

<br/>

## ë‚´ ì½”ë“œ
ì •ë ¬ í›„ í™•ì¸

*1ms, 11.4MB*
```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        sort(begin(words), end(words), [](const string& s1, const string& s2) {
            return s1.length() > s2.length();
        }); // ê¸¸ì´ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬

        vector<string> answer;
        int n = words.size();
        for(int i{1};i<n;++i) {
            for(int j{};j<i;++j) {
                if(words[j].find(words[i]) != string::npos) {
                    answer.push_back(words[i]);
                    break;
                }
            }
        }
        return answer;
    }
};
```

<br/>

## Solution

### Approach 1: Brute Force
- *4ms, 11.32MB*
- Complexity
  - Let $n$ be the size of the `words` array and $m$ be the length of the longest string in `words`.
  - Time Complexity: $O(m^2 \times n^2)$
  - Space Complexity: $O(1)$

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string> &words) {
        vector<string> matchingWords;

        // Iterate through each word in the input list.
        for (int currentWordIndex = 0; currentWordIndex < words.size();
             currentWordIndex++) {
            // Compare the current word with all other words.
            for (int otherWordIndex = 0; otherWordIndex < words.size();
                 otherWordIndex++) {
                if (currentWordIndex == otherWordIndex)
                    continue;  // Skip comparing the word with itself.

                // Check if the current word is a substring of another word.
                if (isSubstringOf(words[currentWordIndex],
                                  words[otherWordIndex])) {
                    // Add it to the result list if true.
                    matchingWords.push_back(words[currentWordIndex]);
                    break;  // No need to check further for this word.
                }
            }
        }

        return matchingWords;
    }

private:
    // Helper function to check if `sub` is a substring of `main`.
    bool isSubstringOf(string &sub, string &main) {
        // Loop through possible starting indices in `main`.
        for (int startIndex = 0; startIndex < main.size(); startIndex++) {
            bool subFits = true;

            // Check if the substring matches from the current start index.
            for (int subIndex = 0; subIndex < sub.size(); subIndex++) {
                if (startIndex + subIndex >= main.size() ||
                    main[startIndex + subIndex] != sub[subIndex]) {
                    subFits = false;  // The substring doesn't match.
                    break;  // No need to continue further for this start index.
                }
            }

            if (subFits) {
                return true;  // Found a match, return true.
            }
        }

        return false;  // No match found.
    }
};
```

<br/>

#### GPT
ì´ ì½”ë“œëŠ” `stringMatching`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì—¬ **ì£¼ì–´ì§„ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì—ì„œ ë‹¤ë¥¸ ë¬¸ìì—´ì˜ ë¶€ë¶„ ë¬¸ìì—´ì¸ ë‹¨ì–´ë“¤ì„ ì°¾ëŠ”** ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.  

---

## **ğŸ“Œ ì½”ë“œ ì„¤ëª…**
### **1ï¸âƒ£ `stringMatching` í•¨ìˆ˜ (ë©”ì¸ ë¡œì§)**
```cpp
vector<string> stringMatching(vector<string> &words) {
    vector<string> matchingWords;
```
- `words`: ì…ë ¥ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: `["mass", "as", "hero", "superhero"]`)
- `matchingWords`: ë¶€ë¶„ ë¬¸ìì—´ì¸ ë‹¨ì–´ë“¤ì„ ì €ì¥í•  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸

```cpp
// Iterate through each word in the input list.
for (int currentWordIndex = 0; currentWordIndex < words.size();
     currentWordIndex++) {
```
- `currentWordIndex`: í˜„ì¬ ê²€ì‚¬ ì¤‘ì¸ ë‹¨ì–´ì˜ ì¸ë±ìŠ¤

```cpp
    // Compare the current word with all other words.
    for (int otherWordIndex = 0; otherWordIndex < words.size();
         otherWordIndex++) {
```
- `otherWordIndex`: í˜„ì¬ ë‹¨ì–´(`words[currentWordIndex]`)ë¥¼ ë‹¤ë¥¸ ë‹¨ì–´(`words[otherWordIndex]`)ì™€ ë¹„êµ

```cpp
        if (currentWordIndex == otherWordIndex)
            continue;  // Skip comparing the word with itself.
```
- ìê¸° ìì‹ ê³¼ ë¹„êµí•˜ëŠ” ê²ƒì€ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ê±´ë„ˆëœ€

```cpp
        if (isSubstringOf(words[currentWordIndex], words[otherWordIndex])) {
            matchingWords.push_back(words[currentWordIndex]);
            break;  // No need to check further for this word.
        }
```
- `isSubstringOf` í•¨ìˆ˜(ë¶€ë¶„ ë¬¸ìì—´ ì—¬ë¶€ ê²€ì‚¬)ë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ë‹¨ì–´ê°€ ë‹¤ë¥¸ ë‹¨ì–´ì˜ ë¶€ë¶„ ë¬¸ìì—´ì´ë©´ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³  **ë” ì´ìƒ ë¹„êµí•˜ì§€ ì•Šê³  break**.

---

### **2ï¸âƒ£ `isSubstringOf` í•¨ìˆ˜ (ë¶€ë¶„ ë¬¸ìì—´ ê²€ì‚¬)**
```cpp
bool isSubstringOf(string &sub, string &main) {
```
- `sub`: ë¶€ë¶„ ë¬¸ìì—´ì¸ì§€ ê²€ì‚¬í•  ë‹¨ì–´
- `main`: ê²€ì‚¬ ëŒ€ìƒ ë‹¨ì–´ (í˜„ì¬ ë‹¨ì–´ê°€ ì´ ë‹¨ì–´ì˜ ë¶€ë¶„ ë¬¸ìì—´ì¸ì§€ í™•ì¸)

```cpp
for (int startIndex = 0; startIndex < main.size(); startIndex++) {
    bool subFits = true;
```
- `startIndex`: `main` ë¬¸ìì—´ì—ì„œ `sub`ì„ ê²€ì‚¬í•  ì‹œì‘ ìœ„ì¹˜
- `subFits`: `sub`ì´ `main`ì˜ íŠ¹ì • ìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ”ì§€ ì—¬ë¶€

```cpp
    for (int subIndex = 0; subIndex < sub.size(); subIndex++) {
        if (startIndex + subIndex >= main.size() ||
            main[startIndex + subIndex] != sub[subIndex]) {
            subFits = false;
            break;
        }
    }
```
- `subIndex`: `sub`ì˜ ë¬¸ì ì¸ë±ìŠ¤
- `main[startIndex + subIndex]`ê°€ `sub[subIndex]`ì™€ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ `subFits = false`ë¡œ ì„¤ì •í•˜ê³  ë£¨í”„ ì¢…ë£Œ

```cpp
    if (subFits) {
        return true;
    }
```
- `subFits == true`ë¼ë©´ `sub`ì´ `main`ì˜ ë¶€ë¶„ ë¬¸ìì—´ì´ë¯€ë¡œ `true` ë°˜í™˜

```cpp
return false;  // No match found.
```
- ëê¹Œì§€ ê²€ì‚¬í–ˆëŠ”ë° ë¶€ë¶„ ë¬¸ìì—´ì´ ì•„ë‹ˆë¼ë©´ `false` ë°˜í™˜

---

## **ğŸ“Œ ì˜ˆì œ ì‹¤í–‰**
### **ì…ë ¥**
```cpp
vector<string> words = {"mass", "as", "hero", "superhero"};
Solution sol;
vector<string> result = sol.stringMatching(words);
```

### **ê° ë¹„êµ ê³¼ì •**
1. `"mass"` vs `"as"` â†’ âŒ `"as"`ëŠ” `"mass"`ì˜ ë¶€ë¶„ ë¬¸ìì—´ì´ì§€ë§Œ, ë°˜ëŒ€ê°€ ì•„ë‹˜
2. `"mass"` vs `"hero"` â†’ âŒ
3. `"mass"` vs `"superhero"` â†’ âŒ
4. `"as"` vs `"mass"` â†’ âœ… `"as"`ëŠ” `"mass"`ì˜ ë¶€ë¶„ ë¬¸ìì—´ â†’ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€  
5. `"hero"` vs `"mass"` â†’ âŒ
6. `"hero"` vs `"superhero"` â†’ âœ… `"hero"`ëŠ” `"superhero"`ì˜ ë¶€ë¶„ ë¬¸ìì—´ â†’ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€  
7. `"superhero"` vs `"mass"`, `"as"`, `"hero"` â†’ âŒ

### **ì¶œë ¥**
```cpp
["as", "hero"]
```

---

## **ğŸ“Œ ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
1. **ë©”ì¸ ë£¨í”„ (`stringMatching`)**
   - `words.size()`ë¥¼ **n**ì´ë¼ í•˜ë©´, ë‘ ê°œì˜ ì¤‘ì²©ëœ ë£¨í”„ì—ì„œ ë¹„êµ ìˆ˜í–‰ $\rightarrow$ $O(n^2)$
   
2. **`isSubstringOf` í•¨ìˆ˜**
   - ë‘ ë¬¸ìì—´ ê¸¸ì´ë¥¼ ê°ê° `m`, `l`ì´ë¼ í•˜ë©´ ìµœëŒ€ $O(ml)$
   - ìµœì•…ì˜ ê²½ìš° `m â‰ˆ l â‰ˆ words`ì˜ ìµœëŒ€ ê¸¸ì´ì¼ ìˆ˜ ìˆìŒ $\rightarrow$ $O(n^2 \cdot m)$
   
3. **ì´ ì‹œê°„ ë³µì¡ë„**
   - $O(n^2 \cdot m)$ (ìµœì•…ì˜ ê²½ìš°, `m`ì´ í¬ë©´ ë§¤ìš° ë¹„íš¨ìœ¨ì )

---

## **ğŸ“Œ ë” íš¨ìœ¨ì ì¸ ë°©ë²• $O(n \log n + n \cdot m)$**
í˜„ì¬ `isSubstringOf` í•¨ìˆ˜ê°€ ë¹„íš¨ìœ¨ì ì´ë¯€ë¡œ **C++ì˜ `find` í•¨ìˆ˜ë¥¼ í™œìš©**í•˜ë©´ ì†ë„ë¥¼ ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### **ê°œì„ ëœ ì½”ë“œ**
```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string> &words) {
        vector<string> matchingWords;
        sort(words.begin(), words.end(), [](const string &a, const string &b) {
            return a.size() < b.size(); // ì§§ì€ ë‹¨ì–´ë¶€í„° ê²€ì‚¬
        });

        for (int i = 0; i < words.size(); i++) {
            for (int j = i + 1; j < words.size(); j++) {
                if (words[j].find(words[i]) != string::npos) {
                    matchingWords.push_back(words[i]);
                    break;
                }
            }
        }

        return matchingWords;
    }
};
```

### **ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
1. **ì •ë ¬** $\rightarrow$ $O(n \log n)$
2. **ì´ì¤‘ ë£¨í”„ ê²€ì‚¬ (`find` í•¨ìˆ˜ ì‚¬ìš©)** $\rightarrow$ $O(n \cdot m)$
3. **ì´ ì‹œê°„ ë³µì¡ë„** $\rightarrow$ $O(n \log n + n \cdot m)$  
   âœ… ê¸°ì¡´ $O(n^2 \cdot m)$ ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„!  

---

## **ğŸ“Œ ê²°ë¡ **
âœ… **ê¸°ì¡´ ì½”ë“œ $O(n^2 \cdot m)$**  
- ì´ì¤‘ ë£¨í”„ + ì§ì ‘ êµ¬í˜„í•œ ë¶€ë¶„ ë¬¸ìì—´ ê²€ì‚¬ â†’ **ë¹„íš¨ìœ¨ì **  

âœ… **ê°œì„ ëœ ì½”ë“œ $O(n \log n + n \cdot m)$**  
- **ì •ë ¬ í›„** C++ `find()` í•¨ìˆ˜ ì‚¬ìš© â†’ **í›¨ì”¬ ë¹ ë¦„!**  

ğŸ”¥ **`find()`ë¥¼ í™œìš©í•œ ê°œì„ ëœ ì½”ë“œê°€ ë” íš¨ìœ¨ì ì´ë¯€ë¡œ ì¶”ì²œ!** ğŸ”¥  

<br/>

### Approach 2: KMP Algorithm
- *1ms, 11.73MB*
- Complexity
  - Let $n$ be the size of the `words` array and $m$ be the length of the longest string in `words`.
  - Time Complexity: $O(m \times n^2)$
  - Space Complexity: $O(m)$

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string> &words) {
        vector<string> matchingWords;

        for (int currentWordIndex = 0; currentWordIndex < words.size();
             currentWordIndex++) {
            vector<int> lps = computeLPSArray(words[currentWordIndex]);
            // Compare the current word with all other words.
            for (int otherWordIndex = 0; otherWordIndex < words.size();
                 otherWordIndex++) {
                if (currentWordIndex == otherWordIndex)
                    continue;  // Skip comparing the word with itself.

                // Check if the current word is a substring of another word.
                if (isSubstringOf(words[currentWordIndex],
                                  words[otherWordIndex], lps)) {
                    matchingWords.push_back(words[currentWordIndex]);
                    break;  // No need to check further for this word.
                }
            }
        }

        return matchingWords;
    }

private:
    // Function to compute the LPS (Longest Prefix Suffix) array for the
    // substring `sub`.
    vector<int> computeLPSArray(string &sub) {
        vector<int> lps(sub.size(), 0);  // Initialize the LPS array with 0.
        int currentIndex = 1;            // Start from the second character.
        // Length of the current longest prefix which is also a suffix.
        int len = 0;

        while (currentIndex < sub.size()) {
            if (sub[currentIndex] == sub[len]) {
                len++;  // If the current characters match, extend the prefix.
                lps[currentIndex] = len;  // Store the length of the prefix.
                currentIndex++;
            } else {
                if (len > 0) {
                    len = lps[len - 1];  // Backtrack using LPS array to find a
                                         // shorter match.
                } else {
                    currentIndex++;
                }
            }
        }
        return lps;
    }

    // Function to check if `sub` is a substring of `main` using the KMP
    // algorithm.
    bool isSubstringOf(string &sub, string &main, vector<int> &lps) {
        int mainIndex = 0;  // Pointer for `main`.
        int subIndex = 0;   // Pointer for `sub`.

        while (mainIndex < main.size()) {
            if (main[mainIndex] == sub[subIndex]) {
                subIndex++;
                mainIndex++;
                if (subIndex == sub.size()) return true;  // Found a match.
            } else {
                if (subIndex > 0) {
                    // Use the LPS to skip unnecessary comparisons.
                    subIndex = lps[subIndex - 1];
                } else {
                    mainIndex++;
                }
            }
        }
        return false;  // No match found.
    }
};
```

<br/>

#### GPT
ì´ ì½”ë“œëŠ” **KMP ì•Œê³ ë¦¬ì¦˜ (Knuth-Morris-Pratt)** ì„ ì´ìš©í•˜ì—¬ ì£¼ì–´ì§„ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì—ì„œ **ë‹¤ë¥¸ ë¬¸ìì—´ì˜ ë¶€ë¶„ ë¬¸ìì—´ì¸ ë‹¨ì–´ë“¤ì„ ì°¾ëŠ”** íš¨ìœ¨ì ì¸ ë°©ë²•ì„ êµ¬í˜„í•©ë‹ˆë‹¤.  

âœ… **ê¸°ì¡´ì˜ ë‹¨ìˆœí•œ $O(n^2 \cdot m)$ íƒìƒ‰ì„ ê°œì„ í•˜ì—¬ $O(n \cdot m)$ ë³µì¡ë„ë¥¼ ê°–ëŠ” KMP ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•œ ì½”ë“œì…ë‹ˆë‹¤.**  

---

## **ğŸ“Œ ì½”ë“œ ë¶„ì„**
### **1ï¸âƒ£ `stringMatching` í•¨ìˆ˜ (ë©”ì¸ ë¡œì§)**
```cpp
vector<string> stringMatching(vector<string> &words) {
    vector<string> matchingWords;

    for (int currentWordIndex = 0; currentWordIndex < words.size();
         currentWordIndex++) {
        vector<int> lps = computeLPSArray(words[currentWordIndex]); // LPS ë°°ì—´ ê³„ì‚°
```
- `words[currentWordIndex]`ê°€ ë‹¤ë¥¸ ë‹¨ì–´ì˜ **ë¶€ë¶„ ë¬¸ìì—´ì¸ì§€ í™•ì¸**í•˜ê¸° ìœ„í•´ **LPS (Longest Prefix Suffix) ë°°ì—´**ì„ ë¯¸ë¦¬ ê³„ì‚°

```cpp
        for (int otherWordIndex = 0; otherWordIndex < words.size();
             otherWordIndex++) {
            if (currentWordIndex == otherWordIndex)
                continue;  // ìê¸° ìì‹ ê³¼ ë¹„êµí•˜ëŠ” ê²½ìš° ê±´ë„ˆë›´ë‹¤.
```
- `words[currentWordIndex]`ë¥¼ `words[otherWordIndex]`ì˜ ë¶€ë¶„ ë¬¸ìì—´ë¡œ ê²€ì‚¬

```cpp
            if (isSubstringOf(words[currentWordIndex], words[otherWordIndex], lps)) {
                matchingWords.push_back(words[currentWordIndex]);
                break;  // ì´ë¯¸ ë¶€ë¶„ ë¬¸ìì—´ë¡œ í™•ì¸ë˜ë©´ ë” ì´ìƒ ê²€ì‚¬í•˜ì§€ ì•ŠìŒ
            }
```
- `isSubstringOf` (KMP ì•Œê³ ë¦¬ì¦˜ í™œìš©)ë¥¼ í†µí•´ ë¶€ë¶„ ë¬¸ìì—´ì¸ì§€ í™•ì¸
- **ë¶€ë¶„ ë¬¸ìì—´ì´ë©´ `matchingWords`ì— ì¶”ê°€ í›„ ë°”ë¡œ break** $\rightarrow$ **ë¶ˆí•„ìš”í•œ ì—°ì‚° ë°©ì§€**

---

### **2ï¸âƒ£ `computeLPSArray` í•¨ìˆ˜ (LPS ë°°ì—´ ê³„ì‚°)**
LPS(Longest Prefix Suffix) ë°°ì—´ì€ KMP ì•Œê³ ë¦¬ì¦˜ì—ì„œ **ë°˜ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê±´ë„ˆë›°ê¸° ìœ„í•´ ì‚¬ìš©**ë©ë‹ˆë‹¤.

```cpp
vector<int> computeLPSArray(string &sub) {
    vector<int> lps(sub.size(), 0);  // ëª¨ë“  ê°’ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™”
    int currentIndex = 1;            // ì¸ë±ìŠ¤ 1ë¶€í„° ì‹œì‘
    int len = 0;  // í˜„ì¬ê¹Œì§€ì˜ LPS ê¸¸ì´ (ê°€ì¥ ê¸´ ì ‘ë‘ì‚¬ì´ë©´ì„œ ì ‘ë¯¸ì‚¬)
```
- `lps[i]`ëŠ” `sub[0:i]`ê¹Œì§€ì˜ ë¶€ë¶„ ë¬¸ìì—´ì—ì„œ **ê°€ì¥ ê¸´ ì ‘ë‘ì‚¬ = ì ‘ë¯¸ì‚¬ ê¸¸ì´**ë¥¼ ì €ì¥  
- **ì´ì „ê¹Œì§€ì˜ LPS ê°’ì„ í™œìš©í•˜ì—¬ ì¤‘ë³µëœ ë¹„êµë¥¼ í”¼í•¨**  

```cpp
    while (currentIndex < sub.size()) {
        if (sub[currentIndex] == sub[len]) {  
            len++;  // ì ‘ë‘ì‚¬ì™€ ì ‘ë¯¸ì‚¬ê°€ ì¼ì¹˜í•˜ëŠ” ê²½ìš° ê¸¸ì´ ì¦ê°€
            lps[currentIndex] = len;
            currentIndex++;
        } else {
            if (len > 0) {
                len = lps[len - 1];  // ì´ì „ LPS ê°’ì„ í™œìš©í•˜ì—¬ backtrack
            } else {
                currentIndex++;  // ì¼ì¹˜í•˜ëŠ” ì ‘ë‘ì‚¬ê°€ ì—†ìœ¼ë©´ ë‹¤ìŒ ë¬¸ìë¡œ ì´ë™
            }
        }
    }
    return lps;
}
```
- **ì¤‘ë³µ ë¹„êµë¥¼ í”¼í•˜ê¸° ìœ„í•´ ì´ì „ LPS ê°’ì„ í™œìš©í•˜ì—¬ ì´ë™**  
- **ì‹œê°„ ë³µì¡ë„: O(m) (mì€ `sub`ì˜ ê¸¸ì´)**  

---

### **3ï¸âƒ£ `isSubstringOf` í•¨ìˆ˜ (KMP ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜)**
```cpp
bool isSubstringOf(string &sub, string &main, vector<int> &lps) {
    int mainIndex = 0;  // `main`ì˜ í˜„ì¬ ìœ„ì¹˜
    int subIndex = 0;   // `sub`ì˜ í˜„ì¬ ìœ„ì¹˜
```
- `main`ì—ì„œ `sub`ì„ ê²€ìƒ‰í•  ë•Œ, í˜„ì¬ íƒìƒ‰ ì¤‘ì¸ **ì¸ë±ìŠ¤(`mainIndex`, `subIndex`)ë¥¼ ìœ ì§€**  

```cpp
    while (mainIndex < main.size()) {
        if (main[mainIndex] == sub[subIndex]) {
            subIndex++;
            mainIndex++;
            if (subIndex == sub.size()) return true;  // `sub` ì „ì²´ê°€ ì¼ì¹˜í•˜ë©´ ë°˜í™˜
        } else {
            if (subIndex > 0) {
                subIndex = lps[subIndex - 1];  // LPS ë°°ì—´ì„ ì‚¬ìš©í•´ ê±´ë„ˆë›°ê¸°
            } else {
                mainIndex++;  // ì²« ë²ˆì§¸ ë¬¸ìë¶€í„° ë¶ˆì¼ì¹˜í•˜ë©´ ë‹¤ìŒ ë¬¸ìë¡œ ì´ë™
            }
        }
    }
    return false;  // ì¼ì¹˜í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì´ ì—†ìŒ
}
```
- `LPS` ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ **ë¶ˆí•„ìš”í•œ ë¹„êµ ì—†ì´ ê²€ìƒ‰**  
- **ì‹œê°„ ë³µì¡ë„: $O(n)$ (nì€ `main`ì˜ ê¸¸ì´)**  

---

## **ğŸ“Œ ì˜ˆì œ ì‹¤í–‰**
### **ì…ë ¥**
```cpp
vector<string> words = {"mass", "as", "hero", "superhero"};
Solution sol;
vector<string> result = sol.stringMatching(words);
```

### **ë‹¨ê³„ë³„ ì§„í–‰**
#### **LPS ë°°ì—´ ê³„ì‚°**
1. `"mass"`ì˜ LPS ë°°ì—´: `[0, 0, 0, 0]`
2. `"as"`ì˜ LPS ë°°ì—´: `[0, 0]`
3. `"hero"`ì˜ LPS ë°°ì—´: `[0, 0, 0, 0]`
4. `"superhero"`ì˜ LPS ë°°ì—´: `[0, 0, 0, 0, 0, 0, 0, 0, 0]`

#### **ë¶€ë¶„ ë¬¸ìì—´ ê²€ì‚¬ (KMP)**
- `"as"`ëŠ” `"mass"`ì˜ ë¶€ë¶„ ë¬¸ìì—´ â†’ ì¶”ê°€ âœ…  
- `"hero"`ëŠ” `"superhero"`ì˜ ë¶€ë¶„ ë¬¸ìì—´ â†’ ì¶”ê°€ âœ…  

#### **ì¶œë ¥**
```cpp
["as", "hero"]
```

---

## **ğŸ“Œ ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
### **1ï¸âƒ£ `computeLPSArray` (LPS ë°°ì—´ ê³„ì‚°)**
- `O(m)`, `m`ì€ `sub`ì˜ ê¸¸ì´

### **2ï¸âƒ£ `isSubstringOf` (KMP ê²€ìƒ‰)**
- `O(n)`, `n`ì€ `main`ì˜ ê¸¸ì´

### **3ï¸âƒ£ `stringMatching` í•¨ìˆ˜ (ì „ì²´ ì‹¤í–‰)**
- `O(n * m)`, ì—¬ê¸°ì„œ `n`ì€ `words` ë¦¬ìŠ¤íŠ¸ í¬ê¸°, `m`ì€ ê° ë‹¨ì–´ ê¸¸ì´  
- **ë¹„êµì  í° ì…ë ¥ì—ì„œë„ íš¨ìœ¨ì ìœ¼ë¡œ ë™ì‘**

#### **ì´ ì‹œê°„ ë³µì¡ë„: $O(n \cdot m)$ (ì´ì „ì˜ $O(n^2 \cdot m)$ë³´ë‹¤ ê°œì„ ë¨)**

---

## **ğŸ“Œ ê¸°ì¡´ ì½”ë“œì™€ ë¹„êµ**
| ë°©ë²• | ì‹œê°„ ë³µì¡ë„ | ê°œì„  ì—¬ë¶€ |
|------|------------|----------|
| ë‹¨ìˆœ ë¸Œë£¨íŠ¸í¬ìŠ¤ (`find()`) | $O(n^2 \cdot m)$ | âŒ ëŠë¦¼ |
| **KMP (í˜„ì¬ ì½”ë“œ)** | $O(n \cdot m)$ | âœ… ë¹ ë¦„ |

**ğŸ”¥ KMP ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ë©´ ë¬¸ìì—´ ê²€ìƒ‰ì„ ë”ìš± íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸ”¥**  

---

## **ğŸ“Œ ê²°ë¡ **
âœ… **$O(n \cdot m)$ ë³µì¡ë„ë¡œ ìµœì í™”ëœ KMP ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¶€ë¶„ ë¬¸ìì—´ ê²€ìƒ‰**  
âœ… **ê¸°ì¡´ì˜ $O(n^2 \cdot m)$ ë°©ì‹ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„**  
âœ… **í° ì…ë ¥ì—ì„œë„ íš¨ìœ¨ì **  

<br/>

### Approach 3: Suffix Trie
- *22ms, 27.56MB*
- Complexity
  - Let $n$ be the size of the `words` array and $m$ be the length of the longest string in `words`.
  - Time Complexity: $O(m^2 \times n)$
  - Space Complexity: $O(m^2 \times n)$

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> matchingWords;
        TrieNode* root = new TrieNode();  // Initialize the root of the Trie.

        // Insert all suffixes of each word into the Trie.
        for (const auto& word : words) {
            for (int startIndex = 0; startIndex < word.size(); startIndex++) {
                // Insert each suffix starting from index `startIndex`.
                insertWord(root, word.substr(startIndex));
            }
        }

        // Check each word to see if it exists as a substring in the Trie.
        for (auto word : words) {
            if (isSubstring(root, word)) {
                matchingWords.push_back(word);
            }
        }

        return matchingWords;
    }

private:
    class TrieNode {
    public:
        // Tracks how many times this substring appears in the Trie.
        int frequency;
        // Maps characters to their respective child nodes.
        unordered_map<char, TrieNode*> childNodes;
    };

    // Function to insert a word (or suffix) into the Trie.
    void insertWord(TrieNode* root, const string& word) {
        TrieNode* currentNode = root;
        for (char c : word) {
            // If the character already exists as a child node, move to it.
            if (currentNode->childNodes.find(c) !=
                currentNode->childNodes.end()) {
                currentNode = currentNode->childNodes[c];
                // Increment the frequency of the node.
                currentNode->frequency++;
            } else {
                // If the character does not exist, create a new node.
                TrieNode* newNode = new TrieNode();
                // Initialize the frequency to 1.
                newNode->frequency = 1;
                // Add the new node as a child.
                currentNode->childNodes[c] = newNode;
                currentNode = newNode;  // Move to the new node.
            }
        }
    }

    // Function to check if a word exists as a substring in the Trie.
    bool isSubstring(TrieNode* root, string& word) {
        TrieNode* currentNode = root;  // Start from the root node.
        for (char c : word) {
            // Traverse the Trie following the characters of the word.
            currentNode = currentNode->childNodes[c];
        }
        // A word is a substring or a different string if its frequency in the
        // Trie is greater than 1.
        return currentNode->frequency > 1;
    }
};
```

<br/>

#### GPT
ì´ ì½”ë“œëŠ” **Trie (íŠ¸ë¼ì´) ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ ë¶€ë¶„ ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰**í•˜ëŠ” ë°©ë²•ì„ êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤. ê¸°ì¡´ì˜ **$O(n^2 \cdot m)$ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°–ëŠ” ë¸Œë£¨íŠ¸í¬ìŠ¤ ë°©ì‹ë³´ë‹¤ ê°œì„ ëœ $O(n \cdot m)$ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°–ìŠµë‹ˆë‹¤.** 

---

## **ğŸ“Œ ì½”ë“œ ì„¤ëª…**
### **1ï¸âƒ£ `stringMatching` í•¨ìˆ˜ (ë©”ì¸ ë¡œì§)**
```cpp
vector<string> stringMatching(vector<string>& words) {
    vector<string> matchingWords;
    TrieNode* root = new TrieNode();  // Trieì˜ ë£¨íŠ¸ ë…¸ë“œ ìƒì„±
```
- `matchingWords`: ë¶€ë¶„ ë¬¸ìì—´ì¸ ë‹¨ì–´ë“¤ì„ ì €ì¥í•  ë²¡í„°
- `root`: **Trieì˜ ë£¨íŠ¸ ë…¸ë“œ** (ëª¨ë“  ë‹¨ì–´ì˜ ì ‘ë¯¸ì‚¬ë¥¼ ì €ì¥)

```cpp
// Insert all suffixes of each word into the Trie.
for (const auto& word : words) {
    for (int startIndex = 0; startIndex < word.size(); startIndex++) {
        insertWord(root, word.substr(startIndex)); // ê° ì ‘ë¯¸ì‚¬ë¥¼ Trieì— ì‚½ì…
    }
}
```
- **ê° ë‹¨ì–´ì˜ ëª¨ë“  ì ‘ë¯¸ì‚¬(suffix)ë¥¼ Trieì— ì €ì¥**  
- `word.substr(startIndex)`: `startIndex`ì—ì„œ ì‹œì‘í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì„ `Trie`ì— ì‚½ì…  
  - ì˜ˆ: `"hero"` â†’ ì‚½ì…í•  ì ‘ë¯¸ì‚¬: `["hero", "ero", "ro", "o"]`  

```cpp
// Check each word to see if it exists as a substring in the Trie.
for (auto word : words) {
    if (isSubstring(root, word)) {
        matchingWords.push_back(word);
    }
}
```
- Trieë¥¼ íƒìƒ‰í•˜ì—¬ `word`ê°€ **ë¶€ë¶„ ë¬¸ìì—´ë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸**
- ì¡´ì¬í•˜ë©´ `matchingWords` ë²¡í„°ì— ì¶”ê°€  

---

### **2ï¸âƒ£ TrieNode í´ë˜ìŠ¤**
```cpp
class TrieNode {
public:
    int frequency;  // í•´ë‹¹ ë…¸ë“œë¥¼ ëª‡ ë²ˆ ë°©ë¬¸í–ˆëŠ”ì§€ (ë¶€ë¶„ ë¬¸ìì—´ ë“±ì¥ íšŸìˆ˜)
    unordered_map<char, TrieNode*> childNodes;  // ìì‹ ë…¸ë“œ ì €ì¥
};
```
- **`frequency`**: í•´ë‹¹ ë¶€ë¶„ ë¬¸ìì—´ì´ **Trieì—ì„œ ëª‡ ë²ˆ ë“±ì¥í–ˆëŠ”ì§€** ì €ì¥  
- **`childNodes`**: ìì‹ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” `unordered_map<char, TrieNode*>`  
  - ê° ë¬¸ìë§ˆë‹¤ ìƒˆë¡œìš´ `TrieNode`ë¥¼ ìƒì„±í•˜ì—¬ ì—°ê²°  

---

### **3ï¸âƒ£ `insertWord` í•¨ìˆ˜ (Trieì— ì ‘ë¯¸ì‚¬ ì‚½ì…)**
```cpp
void insertWord(TrieNode* root, const string& word) {
    TrieNode* currentNode = root;
    for (char c : word) {
        if (currentNode->childNodes.find(c) != currentNode->childNodes.end()) {
            currentNode = currentNode->childNodes[c];
            currentNode->frequency++;  // í•´ë‹¹ ë…¸ë“œì˜ ë°©ë¬¸ íšŸìˆ˜ ì¦ê°€
        } else {
            TrieNode* newNode = new TrieNode();
            newNode->frequency = 1;
            currentNode->childNodes[c] = newNode;
            currentNode = newNode;
        }
    }
}
```
- `Trie`ë¥¼ ë”°ë¼ê°€ë©° **ë¬¸ìê°€ ì¡´ì¬í•˜ë©´ ì´ë™í•˜ê³ , ì—†ìœ¼ë©´ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ìƒì„±**  
- `frequency++`: **ì´ ë…¸ë“œê°€ ëª‡ ë²ˆ ë“±ì¥í–ˆëŠ”ì§€ ê¸°ë¡**  

**ì˜ˆì œ ì‹¤í–‰ (`"hero"`)**
```
h â†’ e â†’ r â†’ o
   â†’ r â†’ o
      â†’ o
```
ì´ë ‡ê²Œ `"hero"`ì˜ ëª¨ë“  ì ‘ë¯¸ì‚¬ê°€ Trieì— ì €ì¥ë¨.  

---

### **4ï¸âƒ£ `isSubstring` í•¨ìˆ˜ (ë¶€ë¶„ ë¬¸ìì—´ í™•ì¸)**
```cpp
bool isSubstring(TrieNode* root, string& word) {
    TrieNode* currentNode = root;
    for (char c : word) {
        currentNode = currentNode->childNodes[c];  // Trieë¥¼ ë”°ë¼ê°
    }
    return currentNode->frequency > 1;  // Trieì—ì„œ 2ë²ˆ ì´ìƒ ë“±ì¥í•œ ê²½ìš° ë¶€ë¶„ ë¬¸ìì—´
}
```
- `Trie`ì—ì„œ `word`ë¥¼ ì°¾ê³ , **í•´ë‹¹ ë…¸ë“œì˜ `frequency` ê°’ì´ 1ë³´ë‹¤ í¬ë©´ ë¶€ë¶„ ë¬¸ìì—´**  
- ì¦‰, **ë‹¤ë¥¸ ë‹¨ì–´ì˜ ì¼ë¶€ë¡œ ì—¬ëŸ¬ ë²ˆ ë“±ì¥í–ˆëŠ”ì§€ ì²´í¬**  

---

## **ğŸ“Œ ì˜ˆì œ ì‹¤í–‰**
### **ì…ë ¥**
```cpp
vector<string> words = {"mass", "as", "hero", "superhero"};
Solution sol;
vector<string> result = sol.stringMatching(words);
```

### **Trie êµ¬ì„± ê³¼ì •**
1. `"mass"` â†’ `"mass"`, `"ass"`, `"ss"`, `"s"`
2. `"as"` â†’ `"as"`, `"s"`
3. `"hero"` â†’ `"hero"`, `"ero"`, `"ro"`, `"o"`
4. `"superhero"` â†’ `"superhero"`, `"uperhero"`, `"perhero"`, `"erhero"`, `"rhero"`, `"hero"`, `"ero"`, `"ro"`, `"o"`

Trieì— `"as"`, `"hero"`ê°€ ì—¬ëŸ¬ ë²ˆ ë“±ì¥í•¨ â†’ `matchingWords = ["as", "hero"]`  

### **ì¶œë ¥**
```cpp
["as", "hero"]
```

---

## **ğŸ“Œ ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
### **1ï¸âƒ£ Trie êµ¬ì¶• (`insertWord`)**
- ê° ë‹¨ì–´ì˜ ëª¨ë“  ì ‘ë¯¸ì‚¬ë¥¼ ì‚½ì… â†’ **$O(n \cdot m)$** (ìµœì•…ì˜ ê²½ìš° `m(m+1)/2` ê°œì˜ ì ‘ë¯¸ì‚¬)
- ë‹¨ì–´ ê¸¸ì´ `m`, ë‹¨ì–´ ê°œìˆ˜ `n`ì´ë¯€ë¡œ **í‰ê·  $O(n \cdot m)$**
  
### **2ï¸âƒ£ ë¶€ë¶„ ë¬¸ìì—´ ê²€ìƒ‰ (`isSubstring`)**
- Trieì—ì„œ ë‹¨ì–´ ê²€ìƒ‰ $\rightarrow$ O(m) (ìµœëŒ€ `m`ë²ˆ ë¬¸ì ë¹„êµ)

### **ğŸ“Œ ì´ ì‹œê°„ ë³µì¡ë„**
- **$O(n \cdot m)$** $\rightarrow$ **KMPì™€ ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì„±ëŠ¥**, í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ìƒìˆ˜ ê³„ìˆ˜ê°€ ì‘ì•„ì„œ ë” ë¹ ë¥¼ ìˆ˜ë„ ìˆìŒ!  

---

## **ğŸ“Œ ê¸°ì¡´ ë°©ì‹ê³¼ ë¹„êµ**

| ë°©ë²• | ì‹œê°„ ë³µì¡ë„ | íŠ¹ì§• |
|:---:|:---:|:---:|
| **ë¸Œë£¨íŠ¸í¬ìŠ¤ (`find()`)** | $O(n^2 \cdot m)$ | âŒ ëŠë¦¼ |
| **KMP ì•Œê³ ë¦¬ì¦˜** | $O(n \cdot m)$ | âœ… ë¹ ë¦„ |
| **Trie ì‚¬ìš© (í˜„ì¬ ì½”ë“œ)** | $O(n \cdot m)$ | âœ… ë¹ ë¦„, ë¶€ë¶„ ë¬¸ìì—´ íƒìƒ‰ ìµœì í™” |

ğŸš€ **Trie ë°©ì‹ì€ íŠ¹íˆ ë‹¨ì–´ ìˆ˜ê°€ ë§ê³ , ì¤‘ë³µëœ ì ‘ë¯¸ì‚¬ê°€ ë§ì„ ë•Œ íš¨ìœ¨ì !**  

---

## **ğŸ“Œ ê²°ë¡ **
âœ… **Trieë¥¼ ì‚¬ìš©í•˜ì—¬ $O(n \cdot m)$ ì‹œê°„ ë³µì¡ë„ë¡œ ë¶€ë¶„ ë¬¸ìì—´ ê²€ìƒ‰ ìµœì í™”**  
âœ… **ê° ë‹¨ì–´ì˜ ì ‘ë¯¸ì‚¬ë¥¼ Trieì— ì €ì¥í•˜ì—¬ íš¨ìœ¨ì ì¸ íƒìƒ‰ ê°€ëŠ¥**  
âœ… **KMPì™€ ìœ ì‚¬í•œ ì„±ëŠ¥ì„ ë‚´ë©´ì„œë„, ë‹¤ëŸ‰ì˜ ë¬¸ìì—´ì—ì„œ ë” ë¹ ë¥¼ ìˆ˜ ìˆìŒ**  

---

### **ğŸ”¥ ì–´ë–¤ ë°©ì‹ì´ ê°€ì¥ ì¢‹ì€ê°€?**

| ìƒí™© | ì¶”ì²œ ë°©ë²• |
|:---:|:---:|
| ì‘ì€ ë°ì´í„° (n â‰¤ 1000) | **ë¸Œë£¨íŠ¸í¬ìŠ¤ (`find()`)** |
| ê¸´ ë¬¸ìì—´ì´ ë§ì„ ë•Œ | **KMP ì•Œê³ ë¦¬ì¦˜** |
| ì¤‘ë³µëœ ì ‘ë¯¸ì‚¬ê°€ ë§ì„ ë•Œ | **Trie ì‚¬ìš© (í˜„ì¬ ì½”ë“œ)** |

**ğŸ’¡ TrieëŠ” ë‹¨ìˆœí•œ KMPë³´ë‹¤ ì‹¤ì „ì—ì„œ ë” ì¢‹ì€ ì„±ëŠ¥ì„ ë‚¼ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤!**  

<br/>
