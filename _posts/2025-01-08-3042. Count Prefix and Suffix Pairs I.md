---
layout: post
title: 3042. Count Prefix and Suffix Pairs I
image: Mine/1695470893720.jpg
date: 2025-01-08 20:00:00 +0900
tags: [Problem_Solving]
categories: Problem_Solving
difficulty: Easy
topics: [Array, String, Trie, Rolling Hash, String Matching, Hash Function]
---

# 3042. Count Prefix and Suffix Pairs I
[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/count-prefix-and-suffix-pairs-i/description/?envType=daily-question&envId=2025-01-08)

<br/>

## ë‚´ ì½”ë“œ
ë¬¸ìì—´.

*0ms, 23.24MB*
```cpp
class Solution {
public:
    int countPrefixSuffixPairs(vector<string>& words) {
        int answer{};

        for(int i{};i<words.size();++i) {
            for(int j{i + 1};j<words.size();++j) {
                if(words[j].size() < words[i].size()) continue;

                if(chkPrefix(words[i], words[j]) && chkSuffix(words[i], words[j])) ++answer;
            }
        }

        return answer;
    }
    bool chkPrefix(string& s1, string& s2) {
        bool ret{true};
        for(int i{};i<s1.size();++i) {
            if(s1[i] != s2[i]) {
                ret = false; break;
            }
        }
        return ret;
    }
    bool chkSuffix(string& s1, string& s2) {
        bool ret{true};
        for(int i{};i<s1.size();++i) {
            if(s1[s1.size() - i - 1] != s2[s2.size() - i - 1]) {
                ret = false; break;
            }
        }
        return ret;
    }
};
```

<br/>

## Solution

### Approach 1: Brute Force
- *7ms, 23.34MB*
- Complexity
  - Let $n$ be the number of words in the input array `words`, and let $m$ be the average length of the words.
  - Time Complexity: $O(n^2 \cdot m)$
  - Space Complexity: $O(1)$

```cpp
class Solution {
public:
    int countPrefixSuffixPairs(vector<string>& words) {
        int n = words.size();
        int count = 0;

        // Step 1: Iterate through each pair of words
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                string& str1 = words[i];
                string& str2 = words[j];

                // Step 2: Skip if the first string is larger than the second
                if (str1.size() > str2.size()) continue;

                // Step 3: Check if str1 is both the prefix and suffix of str2
                if (str2.find(str1) == 0 &&
                    str2.rfind(str1) == str2.size() - str1.size()) {
                    ++count;
                }
            }
        }

        // Step 4: Return the total count of prefix-suffix pairs
        return count;
    }
};
```

<br/>

#### GPT
ì´ ì½”ë“œëŠ” **ì£¼ì–´ì§„ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì—ì„œ "prefix-suffix pairs"ë¥¼ ì°¾ê³  ê°œìˆ˜ë¥¼ ì„¸ëŠ” ë¬¸ì œ**ë¥¼ í•´ê²°í•©ë‹ˆë‹¤.  
ì¦‰, **í•œ ë‹¨ì–´ê°€ ë‹¤ë¥¸ ë‹¨ì–´ì˜ ì ‘ë‘ì‚¬(prefix)ì´ë©´ì„œ ì ‘ë¯¸ì‚¬(suffix)ì¸ ê²½ìš°**ë¥¼ ì°¾ì•„ ê°œìˆ˜ë¥¼ ì„¸ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.  

âœ… **ì‹œê°„ ë³µì¡ë„: $O(n^2 * m)$**  
âœ… **íš¨ìœ¨ì ì¸ ê°œì„  ê°€ëŠ¥: $O(n * m)$ (KMP or Trie ì‚¬ìš© ê°€ëŠ¥)**  

---

## **ğŸ“Œ ì½”ë“œ ë¶„ì„**
### **1ï¸âƒ£ `countPrefixSuffixPairs` í•¨ìˆ˜ (ë©”ì¸ ë¡œì§)**
```cpp
int countPrefixSuffixPairs(vector<string>& words) {
    int n = words.size();
    int count = 0;
```
- `n`: `words` ë²¡í„°ì˜ í¬ê¸°  
- `count`: **prefix-suffix ìŒì˜ ê°œìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜**

```cpp
// Step 1: Iterate through each pair of words
for (int i = 0; i < n; ++i) {
    for (int j = i + 1; j < n; ++j) {
```
- **ì´ì¤‘ ë£¨í”„**ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  `(i, j)` ìŒì„ í™•ì¸  
- `i < j`ì´ë¯€ë¡œ ê°™ì€ ë‹¨ì–´ë¼ë¦¬ëŠ” ë¹„êµí•˜ì§€ ì•ŠìŒ  

```cpp
        string& str1 = words[i];
        string& str2 = words[j];

        // Step 2: Skip if the first string is larger than the second
        if (str1.size() > str2.size()) continue;
```
- `str1`ì´ `str2`ë³´ë‹¤ ê¸¸ë©´ `str1`ì´ `str2`ì˜ prefix + suffixê°€ ë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê±´ë„ˆëœ€  

```cpp
        // Step 3: Check if str1 is both the prefix and suffix of str2
        if (str2.find(str1) == 0 &&
            str2.rfind(str1) == str2.size() - str1.size()) {
            ++count;
        }
```
- **`find(str1) == 0`** â†’ `str1`ì´ `str2`ì˜ ì ‘ë‘ì‚¬(prefix)ì¸ì§€ í™•ì¸  
- **`rfind(str1) == str2.size() - str1.size()`** â†’ `str1`ì´ `str2`ì˜ ì ‘ë¯¸ì‚¬(suffix)ì¸ì§€ í™•ì¸  
- **ë‘˜ ë‹¤ ì°¸ì´ë©´ `count++` ì¦ê°€**  

```cpp
// Step 4: Return the total count of prefix-suffix pairs
return count;
```
- **ìµœì¢…ì ìœ¼ë¡œ `count`ë¥¼ ë°˜í™˜**  

---

## **ğŸ“Œ ì˜ˆì œ ì‹¤í–‰**
### **ì…ë ¥**
```cpp
vector<string> words = {"abc", "abcabc", "xyz", "xyzxyz"};
Solution sol;
int result = sol.countPrefixSuffixPairs(words);
```

### **ë‹¨ê³„ë³„ ì‹¤í–‰**
#### **ë¬¸ìì—´ ìŒ ê²€ì‚¬**

| i | j | words[i] | words[j] | prefix ê²€ì‚¬ (`find() == 0`) | suffix ê²€ì‚¬ (`rfind() == end`) | count ì¦ê°€? |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 1 | "abc"   | "abcabc" | âœ… "abc"ëŠ” ì ‘ë‘ì‚¬ | âœ… "abc"ëŠ” ì ‘ë¯¸ì‚¬ | âœ… ì¦ê°€ |
| 0 | 2 | "abc"   | "xyz"    | âŒ "abc"ëŠ” ì ‘ë‘ì‚¬ ì•„ë‹˜ | âŒ | âŒ |
| 0 | 3 | "abc"   | "xyzxyz" | âŒ | âŒ | âŒ |
| 1 | 2 | "abcabc" | "xyz"   | âŒ | âŒ | âŒ |
| 1 | 3 | "abcabc" | "xyzxyz" | âŒ | âŒ | âŒ |
| 2 | 3 | "xyz"   | "xyzxyz" | âœ… "xyz"ëŠ” ì ‘ë‘ì‚¬ | âœ… "xyz"ëŠ” ì ‘ë¯¸ì‚¬ | âœ… ì¦ê°€ |

#### **ì¶œë ¥**
```cpp
2  // ("abc", "abcabc") + ("xyz", "xyzxyz")
```

---

## **ğŸ“Œ ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
### **1ï¸âƒ£ ì´ì¤‘ ë£¨í”„ (`O(nÂ²)`)**
- ëª¨ë“  `i, j (i < j)` ìŒì„ ë¹„êµ $\rightarrow$ $O(nÂ²)$  

### **2ï¸âƒ£ `find()` ë° `rfind()` í•¨ìˆ˜ (`O(m)`)**
- `find()`ì™€ `rfind()`ëŠ” ìµœì•…ì˜ ê²½ìš° $O(m)$ (mì€ ë‹¨ì–´ ê¸¸ì´)  

### **ì´ ì‹œê°„ ë³µì¡ë„**
âœ… $O(n^2 * m)$ (ìµœì•…ì˜ ê²½ìš°)  

ğŸš€ **íš¨ìœ¨ì ì¸ ê°œì„  ê°€ëŠ¥ (ì•„ë˜ ì°¸ê³  â¬‡ï¸)**  

---

## **ğŸ“Œ ê°œì„  ë°©ë²• (O(n * m))**
### **1ï¸âƒ£ KMP (Knuth-Morris-Pratt) ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©**
âœ… `find()`ì™€ `rfind()` ëŒ€ì‹  KMP ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë©´ **O(m)** ëŒ€ì‹  **O(m) (íƒìƒ‰ ìµœì í™”)**  
âœ… **ì´ì¤‘ ë£¨í”„ ì œê±° ê°€ëŠ¥ $\rightarrow$ $O(n * m)$**  

### **ê°œì„ ëœ ì½”ë“œ (KMP)**
```cpp
class Solution {
public:
    int countPrefixSuffixPairs(vector<string>& words) {
        int n = words.size();
        int count = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                string& prefix = words[i];
                string& fullStr = words[j];

                if (prefix.size() > fullStr.size()) continue;

                if (isPrefix(fullStr, prefix) && isSuffix(fullStr, prefix)) {
                    ++count;
                }
            }
        }
        return count;
    }

private:
    bool isPrefix(const string& fullStr, const string& prefix) {
        return fullStr.compare(0, prefix.size(), prefix) == 0;
    }

    bool isSuffix(const string& fullStr, const string& suffix) {
        return fullStr.compare(fullStr.size() - suffix.size(), suffix.size(), suffix) == 0;
    }
};
```
### **ê°œì„ ëœ ì½”ë“œì˜ ì‹œê°„ ë³µì¡ë„**
âœ… `isPrefix()` ë° `isSuffix()` $\rightarrow$ **$O(m)$**  
âœ… ì´ì¤‘ ë£¨í”„ $\rightarrow$ **$O(n^2)$**  
âœ… **ì´ $O(n * m)$**  

---

## **ğŸ“Œ ê²°ë¡ **
âœ… **ê¸°ì¡´ ì½”ë“œ $(O(n^2 * m))$**  
- `find()`ì™€ `rfind()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„êµ â†’ **ëŠë¦¼**  
- ë‹¨ì–´ ê¸¸ì´ê°€ ê¸¸ì–´ì§ˆìˆ˜ë¡ ë¹„íš¨ìœ¨ì   

âœ… **ê°œì„ ëœ ì½”ë“œ $(O(n * m))$**  
- `isPrefix()` ë° `isSuffix()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ **ë” ë¹ ë¥´ê²Œ ê²€ì‚¬**  
- **KMPë‚˜ Trieë¥¼ í™œìš©í•˜ë©´ ì¶”ê°€ì ì¸ ì†ë„ í–¥ìƒ ê°€ëŠ¥**  

ğŸš€ **ì¶”ì²œ: $O(n * m)$ ê°œì„  ì½”ë“œ ì‚¬ìš©!** ğŸš€  

---

## **ğŸ“Œ ìµœì¢… ì¶”ì²œ**

| ìƒí™© | ì¶”ì²œ ë°©ë²• |
|:---:|:---:|
| ì…ë ¥ í¬ê¸°ê°€ ì‘ì„ ë•Œ (n â‰¤ 1000) | ê¸°ì¡´ ì½”ë“œ ì‚¬ìš© $(O(n^2 * m))$ |
| ê¸´ ë¬¸ìì—´ì´ ë§ì„ ë•Œ (n > 1000) | ê°œì„ ëœ `isPrefix()` & `isSuffix()` ì‚¬ìš© $(O(n * m))$ |
| ë§¤ìš° í° ë°ì´í„°ì…‹ (n > 10âµ) | Trie / KMP í™œìš© |

ğŸ”¥ **"ë¶€ë¶„ ë¬¸ìì—´" ë¬¸ì œëŠ” í•­ìƒ `find()`ë¥¼ ì“°ì§€ ë§ê³  KMPë‚˜ Trieë¥¼ ê³ ë ¤í•˜ì!"** ğŸ”¥  

<br/>

### Approach 2: Dual Trie
- *24ms, 45.86MB*
- Complexity
  - Let $n$ be the number of words in the input array `words`, and let $m$ be the average length of the words.
  - Time Complexity: $O(n^2 \cdot m)$
  - Space Complexity: $O(n \cdot m)$

```cpp
class Node {
public:
    Node* links[26] = {};

    // Check if the character is present in the current node
    bool contains(char c) { return links[c - 'a'] != NULL; }

    // Insert a new node for the character
    void put(char c, Node* node) { links[c - 'a'] = node; }

    // Get the next node for the character
    Node* next(char c) { return links[c - 'a']; }
};

class Trie {
public:
    Node* root;

    Trie() { root = new Node(); }

    // Insert a word into the Trie
    void insert(string& word) {
        Node* node = root;
        for (char c : word) {
            if (!node->contains(c)) {
                node->put(c, new Node());
            }
            node = node->next(c);
        }
    }

    // Check if the Trie contains a given prefix
    bool startsWith(string& prefix) {
        Node* node = root;
        for (char c : prefix) {
            if (!node->contains(c)) {
                return false;
            }
            node = node->next(c);
        }
        return true;
    }
};

class Solution {
public:
    int countPrefixSuffixPairs(vector<string>& words) {
        int n = words.size();
        int count = 0;

        // Step 1: Iterate over each word
        for (int i = 0; i < n; i++) {
            Trie prefixTrie, suffixTrie;

            // Step 2: Insert the current word into the prefix Trie
            prefixTrie.insert(words[i]);

            // Step 3: Reverse the word and insert it into the suffix Trie
            string revWord = words[i];
            reverse(revWord.begin(), revWord.end());
            suffixTrie.insert(revWord);

            // Step 4: Iterate over all previous words
            for (int j = 0; j < i; j++) {
                // Step 5: Skip words[j] if it is longer than words[i]
                if (words[j].size() > words[i].size()) continue;

                // Step 6: Extract the prefix and reversed prefix of words[j]
                string prefixWord = words[j];
                string revPrefixWord = prefixWord;
                reverse(revPrefixWord.begin(), revPrefixWord.end());

                // Step 7: Check if words[j] is both a prefix and suffix of
                // words[i]
                if (prefixTrie.startsWith(prefixWord) &&
                    suffixTrie.startsWith(revPrefixWord)) {
                    count++;
                }
            }
        }

        // Step 8: Return the total count of valid pairs
        return count;
    }
};
```

<br/>

#### GPT
ì´ ì½”ë“œëŠ” **Trie (íŠ¸ë¼ì´) ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ì—¬ "Prefix-Suffix Pairs" ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ìµœì í™”ëœ ë°©ë²•**ì„ êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤.  

ğŸš€ **ëª©í‘œ:**  
ì£¼ì–´ì§„ `words` ë²¡í„°ì—ì„œ `words[j]`ê°€ `words[i]`ì˜ **ì ‘ë‘ì‚¬(prefix) & ì ‘ë¯¸ì‚¬(suffix)** ë‘˜ ë‹¤ì¸ ê²½ìš° `(j, i)` ìŒì„ ì°¾ì•„ ê°œìˆ˜ë¥¼ ì„¸ê¸°  

âœ… **Trieë¥¼ ì‚¬ìš©í•˜ì—¬ $O(n * m)$ìœ¼ë¡œ ìµœì í™” (ê¸°ì¡´ $O(n^2 * m)$ì—ì„œ ê°œì„ )**  

---

## **ğŸ“Œ ì½”ë“œ ë¶„ì„**
### **1ï¸âƒ£ Trie ìë£Œêµ¬ì¡° êµ¬í˜„**
```cpp
class Node {
public:
    Node* links[26] = {};  // ì•ŒíŒŒë²³ 26ê°œë¥¼ ìœ„í•œ ë°°ì—´

    bool contains(char c) { return links[c - 'a'] != NULL; }
    void put(char c, Node* node) { links[c - 'a'] = node; }
    Node* next(char c) { return links[c - 'a']; }
};
```
- **`Node` í´ë˜ìŠ¤:** ê° ë¬¸ì ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” êµ¬ì¡°ì²´  
- **`links[26]` ë°°ì—´:** ì•ŒíŒŒë²³ 26ê°œ ì €ì¥ (`a-z`)  
- **`contains(c)`, `put(c, node)`, `next(c)`** â†’ íŠ¸ë¼ì´ì—ì„œ ë¬¸ì ê²€ìƒ‰/ì¶”ê°€  

```cpp
class Trie {
public:
    Node* root;
    Trie() { root = new Node(); }

    void insert(string& word) {
        Node* node = root;
        for (char c : word) {
            if (!node->contains(c)) {
                node->put(c, new Node());
            }
            node = node->next(c);
        }
    }

    bool startsWith(string& prefix) {
        Node* node = root;
        for (char c : prefix) {
            if (!node->contains(c)) {
                return false;
            }
            node = node->next(c);
        }
        return true;
    }
};
```
- **`insert()`**: ë‹¨ì–´ë¥¼ Trieì— ì‚½ì…  
- **`startsWith()`**: ì£¼ì–´ì§„ `prefix`ê°€ Trie ë‚´ì— ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì‚¬  

---

### **2ï¸âƒ£ `countPrefixSuffixPairs` í•¨ìˆ˜ (ë©”ì¸ ë¡œì§)**
```cpp
int countPrefixSuffixPairs(vector<string>& words) {
    int n = words.size();
    int count = 0;
```
- `n`: ì…ë ¥ ë²¡í„° `words`ì˜ í¬ê¸°  
- `count`: **Prefix-Suffix Pairs ê°œìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜**  

```cpp
// Step 1: Iterate over each word
for (int i = 0; i < n; i++) {
    Trie prefixTrie, suffixTrie;
```
- `i`ë²ˆì§¸ ë‹¨ì–´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ **ì ‘ë‘ì‚¬ Trie, ì ‘ë¯¸ì‚¬ Trie** ìƒì„±  

```cpp
    // Step 2: Insert the current word into the prefix Trie
    prefixTrie.insert(words[i]);

    // Step 3: Reverse the word and insert it into the suffix Trie
    string revWord = words[i];
    reverse(revWord.begin(), revWord.end());
    suffixTrie.insert(revWord);
```
- `prefixTrie`: `words[i]`ë¥¼ **ê·¸ëŒ€ë¡œ ì‚½ì…** â†’ ì ‘ë‘ì‚¬(prefix) íƒìƒ‰ìš©  
- `suffixTrie`: `words[i]`ë¥¼ **ë’¤ì§‘ì–´ì„œ ì‚½ì…** â†’ ì ‘ë¯¸ì‚¬(suffix) íƒìƒ‰ìš©  

```cpp
    // Step 4: Iterate over all previous words
    for (int j = 0; j < i; j++) {
        // Step 5: Skip words[j] if it is longer than words[i]
        if (words[j].size() > words[i].size()) continue;
```
- `words[j]`ê°€ `words[i]`ë³´ë‹¤ ê¸¸ë©´ ì ‘ë‘ì‚¬+ì ‘ë¯¸ì‚¬ê°€ ë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `continue`  

```cpp
        // Step 6: Extract the prefix and reversed prefix of words[j]
        string prefixWord = words[j];
        string revPrefixWord = prefixWord;
        reverse(revPrefixWord.begin(), revPrefixWord.end());

        // Step 7: Check if words[j] is both a prefix and suffix of words[i]
        if (prefixTrie.startsWith(prefixWord) &&
            suffixTrie.startsWith(revPrefixWord)) {
            count++;
        }
    }
}
```
- `prefixTrie.startsWith(prefixWord)`: `words[j]`ê°€ `words[i]`ì˜ **ì ‘ë‘ì‚¬ì¸ì§€ í™•ì¸**  
- `suffixTrie.startsWith(revPrefixWord)`: `words[j]`ê°€ `words[i]`ì˜ **ì ‘ë¯¸ì‚¬ì¸ì§€ í™•ì¸**  
- **ë‘˜ ë‹¤ ë§Œì¡±í•˜ë©´ `count++` ì¦ê°€**  

```cpp
// Step 8: Return the total count of valid pairs
return count;
```
- ìµœì¢…ì ìœ¼ë¡œ `count` ë°˜í™˜  

---

## **ğŸ“Œ ì˜ˆì œ ì‹¤í–‰**
### **ì…ë ¥**
```cpp
vector<string> words = {"abc", "abcabc", "xyz", "xyzxyz"};
Solution sol;
int result = sol.countPrefixSuffixPairs(words);
```

### **Trie ì‚½ì… & ê²€ìƒ‰ ê³¼ì •**
#### **ë‹¨ì–´ ì‚½ì…**
- `"abc"` â†’ `prefixTrie`, `"cba"` â†’ `suffixTrie`
- `"abcabc"` â†’ `prefixTrie`, `"cbacba"` â†’ `suffixTrie`
- `"xyz"` â†’ `prefixTrie`, `"zyx"` â†’ `suffixTrie`
- `"xyzxyz"` â†’ `prefixTrie`, `"zyxzyx"` â†’ `suffixTrie`

#### **ë‹¨ì–´ ê²€ìƒ‰**

| i | j | words[j] | words[i] | `prefixTrie.startsWith()` | `suffixTrie.startsWith()` | count ì¦ê°€? |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 1 | 0 | "abc"   | "abcabc" | âœ… | âœ… | âœ… ì¦ê°€ |
| 3 | 2 | "xyz"   | "xyzxyz" | âœ… | âœ… | âœ… ì¦ê°€ |

### **ì¶œë ¥**
```cpp
2  // ("abc", "abcabc") + ("xyz", "xyzxyz")
```

---

## **ğŸ“Œ ì‹œê°„ ë³µì¡ë„ ë¶„ì„**
### **1ï¸âƒ£ Trie ì‚½ì… (`insert`)**
- í•œ ë‹¨ì–´ë¥¼ Trieì— ì‚½ì…í•˜ëŠ” ë° **O(m)**
- ëª¨ë“  ë‹¨ì–´ë¥¼ ì‚½ì…í•˜ë©´ **O(n * m)**

### **2ï¸âƒ£ Trie íƒìƒ‰ (`startsWith`)**
- ì ‘ë‘ì‚¬ & ì ‘ë¯¸ì‚¬ í™•ì¸ $\rightarrow$ **O(m)**
- ëª¨ë“  `i, j` ìŒì„ ê²€ì‚¬í•˜ë©´ **O(n * m)**

### **ğŸ“Œ ì´ ì‹œê°„ ë³µì¡ë„**
âœ… **$O(n * m)$** (ì´ì „ $O(n^2 * m)$ë³´ë‹¤ ê°œì„ ë¨)

---

## **ğŸ“Œ ê¸°ì¡´ ë°©ì‹ê³¼ ë¹„êµ**

| ë°©ë²• | ì‹œê°„ ë³µì¡ë„ | íŠ¹ì§• |
|:---:|:---:|:---:|
| **Brute Force (`find()`)** | $O(n^2 * m)$ | âŒ ëŠë¦¼ |
| **KMP ì•Œê³ ë¦¬ì¦˜** | $O(n * m)$ | âœ… ë¹ ë¦„ |
| **Trie ì‚¬ìš© (í˜„ì¬ ì½”ë“œ)** | $O(n * m)$ | âœ… ë¹ ë¦„, íš¨ìœ¨ì  |

ğŸš€ **TrieëŠ” íŠ¹íˆ ë‹¨ì–´ê°€ ë§ê³  ì¤‘ë³µì´ ë§ì„ ë•Œ ë” ë¹ ë¦„!**  

---

## **ğŸ“Œ ê²°ë¡ **
âœ… **Trieë¥¼ ì‚¬ìš©í•˜ì—¬ $O(n * m)$ ì‹œê°„ ë³µì¡ë„ë¡œ ìµœì í™”**  
âœ… **ê¸°ì¡´ $O(n^2 * m)$ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„**  
âœ… **TrieëŠ” ì ‘ë‘ì‚¬ & ì ‘ë¯¸ì‚¬ ê²€ìƒ‰ì— ë§¤ìš° íš¨ìœ¨ì **  

**ğŸ’¡ ì–´ë–¤ ë°©ì‹ì´ ê°€ì¥ ì¢‹ì€ê°€?**

| ìƒí™© | ì¶”ì²œ ë°©ë²• |
|------|---------|
| ì‘ì€ ë°ì´í„° $(n \leq 1000)$ | `find()` ì‚¬ìš© |
| ê¸´ ë¬¸ìì—´ì´ ë§ì„ ë•Œ $(n > 1000)$ | KMP ì•Œê³ ë¦¬ì¦˜ |
| ë§¤ìš° í° ë°ì´í„° $(n > 10^5)$ | Trie ì‚¬ìš© (í˜„ì¬ ì½”ë“œ) |

ğŸ”¥ **ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ TrieëŠ” ê°•ë ¥í•œ ì„±ëŠ¥ í–¥ìƒì„ ì œê³µí•  ìˆ˜ ìˆìŒ!** ğŸ”¥  

<br/>
